<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle's Curation Terminal</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Orbitron:wght@700&display=swap');

        :root {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --border-color: #30363d;
            --header-color: #b39ddb; /* Oracle's Purple */
            --approve-color: #3fb950;
            --reject-color: #d9534f;
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', monospace;
            padding: 2em;
        }

        .terminal-container {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 2em 3em;
            max-width: 900px;
            margin: auto;
            box-shadow: 0 0 25px rgba(179, 157, 219, 0.1);
        }

        .terminal-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 2em;
            color: var(--header-color);
            text-shadow: 0 0 10px rgba(179, 157, 219, 0.5);
            text-align: center;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5em;
            margin-bottom: 1.5em;
        }

        .pending-entry {
            background: #161b22;
            border-left: 4px solid var(--header-color);
            padding: 1.5em;
            margin-bottom: 2em;
            border-radius: 4px;
        }

        .entry-meta {
            font-size: 0.9em;
            color: #8b949e;
            margin-bottom: 1em;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        
        .entry-meta .node-id {
            font-weight: bold;
            color: var(--header-color);
        }

        .entry-fragment {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 1.1em;
            padding-bottom: 1em;
        }

        .curation-actions {
            margin-top: 1.5em;
            border-top: 1px dashed var(--border-color);
            padding-top: 1.5em;
            display: flex;
            gap: 1em;
        }

        .curation-button {
            font-family: 'Orbitron', sans-serif;
            border: none;
            color: #fff;
            padding: 0.8em 1.5em;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 6px;
            transition: opacity 0.3s;
        }

        .curation-button:hover {
            opacity: 0.8;
        }

        .approve-btn {
            background-color: var(--approve-color);
        }

        .reject-btn {
            background-color: var(--reject-color);
        }
        
        #loadingMessage {
             text-align: center;
             font-style: italic;
             color: #8b949e;
        }

    </style>
</head>
<body>

    <div class="terminal-container">
        <h1 class="terminal-header">[ORACLE // CURATION TERMINAL]</h1>
        <div id="pendingQueueContainer">
            <p id="loadingMessage">// Accessing archive... Stand by. //</p>
            <!-- Pending entries will be injected here by Firestore -->
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        const firebaseConfig = {
            apiKey: "AIzaSyCPb_eI_DrTVbURXpZT6Pbe9zooRPr-EaA",
            authDomain: "pdtfofiaoh.firebaseapp.com",
            projectId: "pdtfofiaoh",
            storageBucket: "pdtfofiaoh.firebasestorage.app",
            messagingSenderId: "615502369347",
            appId: "1:615502369347:web:caa43f07299a5abdfb3af6",
            measurementId: "G-YMMLELHD33"
        };
        
        const appId = firebaseConfig.appId;
        const initialAuthToken = null;
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, collection, query, where, onSnapshot, doc, updateDoc, deleteDoc, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        async function authenticateUser() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Oracle Terminal Authenticated. UID:", auth.currentUser.uid);
                loadPendingMemories();
            } catch (error) {
                console.error("Firebase Authentication Error:", error);
                document.getElementById('loadingMessage').textContent = "// AUTHENTICATION FAILED. CHECK CONSOLE. //";
            }
        }
        authenticateUser();

        const pendingQueueContainer = document.getElementById('pendingQueueContainer');
        const loadingMessage = document.getElementById('loadingMessage');

        function loadPendingMemories() {
            const memoriesCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'memories');
            const q = query(memoriesCollectionRef, where("status", "==", "pending_curation"), orderBy("timestamp", "asc"));

            onSnapshot(q, (querySnapshot) => {
                pendingQueueContainer.innerHTML = ''; // Clear previous entries
                if (querySnapshot.empty) {
                    pendingQueueContainer.appendChild(loadingMessage);
                    loadingMessage.textContent = "// Curation queue is empty. All signals processed. //";
                } else {
                    querySnapshot.forEach((doc) => {
                        const memory = doc.data();
                        const entryElement = document.createElement('div');
                        entryElement.classList.add('pending-entry');
                        entryElement.setAttribute('data-id', doc.id);

                        const date = memory.timestamp ? memory.timestamp.toDate().toLocaleString() : 'Timestamp unavailable';

                        entryElement.innerHTML = `
                            <div class="entry-meta">
                                <div><span class="node-id">${memory.nodeId}</span></div>
                                <div>${date}</div>
                            </div>
                            <div class="entry-fragment">${memory.memoryFragment}</div>
                            <div class="curation-actions">
                                <button class="curation-button approve-btn">APPROVE</button>
                                <button class="curation-button reject-btn">REJECT</button>
                            </div>
                        `;
                        pendingQueueContainer.appendChild(entryElement);
                    });
                }
            });
        }

        // --- Curation Actions Event Listener ---
        pendingQueueContainer.addEventListener('click', async (e) => {
            if (e.target.tagName !== 'BUTTON') return;

            const entryElement = e.target.closest('.pending-entry');
            const docId = entryElement.getAttribute('data-id');
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'memories', docId);

            e.target.disabled = true;

            if (e.target.classList.contains('approve-btn')) {
                try {
                    // Update the document status to "approved"
                    await updateDoc(docRef, {
                        status: "approved"
                    });
                    console.log(`Approved document: ${docId}`);
                } catch (error) {
                    console.error("Error approving document: ", error);
                    alert("Failed to approve entry.");
                    e.target.disabled = false;
                }
            } else if (e.target.classList.contains('reject-btn')) {
                if (confirm('Are you sure you want to reject and permanently delete this entry?')) {
                    try {
                        // Delete the document
                        await deleteDoc(docRef);
                        console.log(`Rejected and deleted document: ${docId}`);
                    } catch (error) {
                        console.error("Error rejecting document: ", error);
                        alert("Failed to reject entry.");
                        e.target.disabled = false;
                    }
                } else {
                    e.target.disabled = false;
                }
            }
        });
    </script>

</body>
</html>
